[{"title":"gRPC 中的服务和方法的路由映射","url":"/2025/06/28/gRPC%20%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E8%B7%AF%E7%94%B1%E6%98%A0%E5%B0%84/","content":":::tips\ngRPC 底层靠的是 Protobuf 中定义的“服务名/方法名”，自动生成代码后注册成映射表，匹配请求时**按路径路由到你实现的 C++ 逻辑代码****。你实现的是 handler，gRPC 自动路由和参数序列化/反序列化。  **\n:::\n所以说，可以说 gRPC 是路由的操作？自动生成接口之后，然后我们继承这个自动生成的类，重写这个接口，然后当请求来的时候，gRPC 的任务就是把请求的信息送到我们重写的相应的接口函数中（完成通信）\n\n路由映射在这一步发生服务注册：\nbuilder.RegisterService(&amp;service);\n\nRegisterService 会遍历这个 service 对象（StatusServiceImpl）\n获取其父类 StatusService 里注册的每一个方法名和其 handler（比如 Login, GetChatServer）\n把它们和 protobuf 中定义的 “StatusService/Login”、“StatusService/GetChatServer” 做映射\n\n注：这些路由字符串通常是形如 // 的形式，比如：\n/StatusService/Login/StatusService/GetChatServer\n这就是 gRPC 的 服务/方法映射表，放在 grpc::Server 内部的服务路由器中。\n一句话：\n在服务绑定到 gPRC 构建器的时候，这个注册方法遍历服务对象，获取这个服务父类里面的每一个方法和我们实现的 handler接口（重写的），将它们与 protobuf 中定义的方法所对应。\n这样根据客户端的路由请求，就能指定到目标的服务函数，处理请求，返回应答。\n客户端的请求：\n:method = POST:path = /StatusService/Logincontent-type = application/grpc\ngRPC Server 收到这个请求后：\n\n查找 /StatusService/Login 是哪个服务对象下的哪个方法\n找到你实现的 StatusServiceImpl::Login() 方法\n调用这个函数，传入反序列化好的 LoginReq 对象\n执行你的业务逻辑，返回 LoginRsp，由框架再序列化发回客户端\n\n✅ 这一整套过程是由 gRPC 框架自动完成的，你只要实现好方法即可。\n\n\n","categories":["系统设计"],"tags":["gRPC"]},{"title":"Hello World","url":"/2025/06/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n"},{"title":"the frist blog of my","url":"/2025/06/28/the-frist-blog-of-my/","content":""},{"title":"容器测试","url":"/2025/06/28/onetest/","content":"::: tips\n这是一个提示容器。\n支持**加粗**、[链接](https://hexo.io)等语法。\n:::\n::: warning\n这是一个警告容器，注意格式对齐！\n:::\n"}]